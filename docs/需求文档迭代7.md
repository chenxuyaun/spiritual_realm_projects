## 一、Chat 模式：补齐 router 标记 & turn_index

### 1. state.meta.mode = "chat"

**目标**：让 Router / 日志能明确知道当前是 chat，对后续策略方便（例如优先 chat_generate / chat 模型）。

**给编辑器的说明：**

1. 在 `mm_orch/state.py` 的 `State` 中确认有 `meta`（dict 或专门结构），如果没有就加一个：

   ```python
   @dataclass
   class State:
       ...
       meta: Dict[str, Any] = field(default_factory=dict)
   ```

2. 在 `ConversationManager.handle_turn(...)` 里，每次创建/更新 state 时，设置：

   ```python
   state.meta["mode"] = "chat"
   ```

   如果已有其他 meta 字段（如 router_version），注意保留，只新增/覆盖 `mode` 键。

3. 在 Router（v2/v3）的特征构造处（比如 `mm_orch/router_v3.py`）：

   * 把 `mode=chat` 也作为一个特征（例如加入 `"mode_chat"` 这种 one-hot），或者直接在规则层：

     * 若 `state.meta.get("mode") == "chat"`，优先把候选 workflow 中的 `chat_generate` / `lesson_pack` 提到前面。

> 这样 router_v3 就可以“记忆感知 + 模式感知”，chat 输入不会再被误路由到 rag_qa。

---

### 2. trace 里记录 turn_index

**目标**：方便分析一整个对话里每一轮的问题/答案顺序。

**给编辑器的说明：**

1. 在 `ConversationManager` 或 chat 主循环中，为每个 `conversation_id` 维护一个整型计数：

   ```python
   # 在 ConversationManager 内部
   self.turn_counters[conversation_id] += 1
   turn_index = self.turn_counters[conversation_id]
   ```

2. 在构造 `State` 时写入：

   ```python
   state.meta["turn_index"] = turn_index
   ```

3. 在 `mm_orch/utils/trace.py` 的写 trace 函数中，确保把 `meta` 整个写入 trace，每条记录包含：

   ```json
   {
     "conversation_id": "...",
     "meta": {
       "mode": "chat",
       "turn_index": 3,
       ...
     },
     ...
   }
   ```

> 之后你看 trace 时就能轻松知道：这是本轮对话的第几轮、走了哪个 workflow、router 用的是哪个版本。

---

## 二、lesson_pack：专用 Steps 做“真教案”

你现在的 lesson_pack 还是复用 TeachingPlan/Explain/Exercise，输出上有点“模板化复读”。
我们照你文档 2.1 / 2.2 的规划，做**三段式专用 Step**：

### 1. LessonPlanStep

**职责**：从用户输入的课题，产出：

* `lesson_topic`（标准化课题名）
* `lesson_objectives`（3–5 条）
* `lesson_outline`（3–6 个教学环节）
* `board_plan`（板书要写哪些关键词/例题）

**给编辑器的实现要点：**

* 文件：`mm_orch/steps.py`

* 新建类，例如：

  ```python
  class LessonPlanStep(Step):
      name = "lesson_plan"

      def run(self, state: State, runtime: Runtime) -> State:
          topic = state.question  # 如 "讲授分数的基本概念，面向小学生"
          prompt = build_lesson_plan_prompt(topic)  # 自己封装一个函数
          text = generator_chat(prompt, ...)  # 用你接好的 Qwen chat 模型

          # 解析输出（可以约定一个结构化格式）
          lesson_topic, objectives, outline, board_plan = parse_lesson_plan(text)

          state.lesson_topic = lesson_topic
          state.lesson_objectives = objectives
          state.lesson_outline = outline
          state.board_plan = board_plan
          state.teaching_plan = text  # 若想兼容旧字段可保留
          return state
  ```

* Prompt 建议格式（要模型输出结构化）：

  ```text
  你是一名小学老师，请为下面的课题设计一个教学计划。

  课题：{user_topic}

  请严格按照以下格式输出（不要添加额外说明）：

  【课题】
  （一行，标准化课题名称）

  【教学目标】
  1. ...
  2. ...
  3. ...

  【教学流程】
  1. 导入：...
  2. 新授：...
  3. 练习：...
  4. 小结：...

  【板书设计】
  - 板书要点1
  - 板书要点2
  ```

  然后在 `parse_lesson_plan` 中按这几个标题切分。

---

### 2. LessonExplainStep

**职责**：基于 plan → 生成**完整讲解稿**：

* 输入：`lesson_topic/lesson_objectives/lesson_outline/board_plan`
* 输出：`teaching_text`（适合直接拿去讲）

**给编辑器的说明：**

* 新建 `LessonExplainStep`，在 `run` 中构造 prompt：

  ```text
  你是一名小学{年级}老师，请根据下面的教学设计写一份课堂讲解稿。

  【课题】
  {lesson_topic}

  【教学目标】
  {目标列表...}

  【教学流程】
  {流程分点...}

  【板书设计】
  {板书要点...}

  要求：
  - 面向小学生，语言简单、生动，适当举例。
  - 按教学流程分段书写，每一环节用一小段文字说明老师怎么说、学生大概怎么反应。
  - 不要出现广告、版权声明、公众号语气。
  - 不要写“教学目标是……”之类元话语，只写课堂上老师实际会说的话。

  【讲解稿开始】
  ```

* 用 `generator_chat` 生成，再通过 `apply_quality_guard` 过滤。

---

### 3. LessonExerciseStep

**职责**：生成 5–10 道练习题 + 答案。

**给编辑器的说明：**

* 新类 `LessonExerciseStep`，使用 `lesson_topic + lesson_objectives` 构造 prompt：

  ```text
  请为下面的课题设计 6 道练习题，并给出参考答案。

  【课题】
  {lesson_topic}

  【教学目标】
  {lesson_objectives}

  要求：
  - 面向小学{年级}学生。
  - 题型可以包括：判断题、选择题、填空题、简短计算或小题。
  - 每道题单独编号，并在题目后使用“【答案】...”给出标准答案。
  - 不要出现广告、版权声明等无关内容。

  【练习题开始】
  ```

* 解析时可以简单切分行/编号，先不做太复杂的结构化（你之后可以迭代）。

---

### 4. lesson_pack 工作流串起来 + CLI 输出字段

在 `mm_orch/main.py`：

* 将 lesson_pack workflow 定义为：

  ```python
  WORKFLOWS["lesson_pack"] = [
      "lesson_plan",
      "lesson_explain",
      "lesson_exercises",
  ]
  ```

* CLI 输出时，除了 `Teaching Text` / `Exercises`，增加：

  ```text
  === Lesson Topic ===
  {lesson_topic}

  === Lesson Objectives ===
  1. ...
  2. ...

  === Lesson Outline ===
  1. ...
  2. ...

  === Board Plan ===
  - ...

  === Lesson Content ===
  {teaching_text}

  === Exercises ===
  {exercises}
  ```

这样你一跑：

```bash
python -m mm_orch.main --workflow lesson_pack "讲授分数的基本概念，面向小学生"
```

就能拿到完整“教案 + 板书 + 讲稿 + 习题”的一整包。

---

## 三、本地教学 RAG：加上按 tag 检索

你已经：

* `ingest_docs.py` 支持 `--tag`
* VectorStore 支持 `tags`

现在只差一个“按 tag 检索开关”。

**给编辑器的说明：**

1. 在 `NpyVectorStore.search` 增加可选参数 `required_tags: Optional[List[str]] = None`：

   * 如果 `required_tags` 非空，则只在 `tags` 至少包含其中一个/全部的文档中做相似度搜索。
   * 简单做法：检索前先过滤 `metas`，只保留 tag 匹配的向量子集。

2. 在 `RagAnswerStep` 中，加一个可选字段，比如从 `state.meta["rag_required_tags"]` 读取要用的 tag 列表，并传给 `vector_store.search(...)`。

3. CLI 增加参数（可选）：

   * `--rag-tags teach,math_grade4`
     在 `main.py` 把这个解析成列表，写入 `state.meta["rag_required_tags"]`。

> 这样你就可以：
> 只用教案文档回答教学问题，或者只用“math_grade4”文档回答四年级数学问题。

---

## 四、整体进度确认 & 小结

根据你给的总结，现在状态是：

* ✅ CUDA / 模型配对 / clean_prompt / return_full_text=false 已稳定
* ✅ chat REPL + 会话记忆雏形 已完成
* ✅ lesson_pack 基础链路 已跑通
* ✅ RAG 教学知识库 支持 tag & 友好空 KB 提示
* ✅ 内容质量护栏 已有负面约束 + 生成后过滤
* ✅ 路由 v3 + Qwen Chat 模型 已接入（超出计划）

**下一步最值得做的三件事：**

1. **把 lesson_pack 做成真正能用的教案生产器**（专用 Steps + 结构化输出）。
2. **给 chat 标上 mode=chat + turn_index**，让 router 和 trace 更“懂对话”。
3. **让 RAG 支持 tag 过滤**，真正变成“我的教学资料问答器”。